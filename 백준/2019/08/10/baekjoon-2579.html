<h2 id="문제">문제</h2>

<p><a href="https://www.acmicpc.net/problem/2579">문제 링크</a></p>

<h2 id="어떻게-접근할-것인가">어떻게 접근할 것인가</h2>

<blockquote>
  <ul>
    <li>이 문제를 어떻게 디피로 접근 할 수 있을까?</li>
    <li>연속 3칸은 불가능하다는 특징 때문에 그냥 막 값을 업데이트하면 원하는 결과를 얻을 수 없다.</li>
    <li>모든 갈래를 저장하지 않을 수 있는 방법이 뭐가 있을까?</li>
    <li>각 위치에서 <strong>한칸 이전에서 온 맥스와 두칸 이전에서 온 맥스</strong>를 저장한다면 중간에 정보가 날아가지 않고 답을 찾을 수 있다.</li>
    <li>그 정보를 위해서 d[계단 개수][2] 짜리 어레이를 하나 준비한다.</li>
    <li>0번째에는 1칸전에서 온 맥스를 1번째에는 2칸전에서 온 맥스를 저장한다.</li>
  </ul>
</blockquote>

<h2 id="코드">코드</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;cstdio&gt;
using namespace std;

int n, w[303], d[303][2];

int main(){

    scanf("%d", &amp;n);
    for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;w[i]);
    d[1][0] = d[1][1] = w[1];
    d[2][0] = d[2][1] = w[2];
    for(int i = 1; i &lt;= n; i++){
        //한칸전에서 왔다면 두칸 이동한 위치 업데이트
        if(d[i][0] + w[i + 2] &gt; d[i + 2][0])d[i + 2][0] = d[i][0] + w[i + 2];
        if(d[i][0] + w[i + 2] &gt; d[i + 2][1])d[i + 2][1] = d[i][0] + w[i + 2];
        //두칸전에서 왔다면 한칸 이동하여 한칸 정보 업데이트하고, 두칸 이동한 위치 모두 업데이트
        if(d[i][1] + w[i + 1] &gt; d[i + 1][0])d[i + 1][0] = d[i][1] + w[i + 1]; 
        if(d[i][1] + w[i + 2] &gt; d[i + 2][0])d[i + 2][0] = d[i][1] + w[i + 2];
        if(d[i][1] + w[i + 2] &gt; d[i + 2][1])d[i + 2][1] = d[i][1] + w[i + 2];
    }
    printf("%d", d[n][0] &gt; d[n][1] ? d[n][0] : d[n][1]);
}
</code></pre></div></div>

<blockquote>
  <ul>
    <li>이전에 한번 이동한 경우(0번째)에는 두칸을 이동하여 해당 위치의 0, 1 모두를 업데이트 한다.</li>
    <li>이전에 두번 이동한 경우(1번째)에는 한칸 이동하여 해당 위치의 0번째를 업데이트하고 두번 이동한 위치의 0,1번째 모두를 업데이트한다.</li>
  </ul>
</blockquote>

<h2 id="느낀점">느낀점</h2>

<blockquote>
  <ul>
    <li>디피를 잘 접근하기 위해서는 문제를 잘 이해하는 것이 매우 중요한 것 같다.</li>
    <li>다음 문제는 코드로 바로 들어가지 않고 생각을 한 후에 진행해야겠다.</li>
  </ul>
</blockquote>
